[TOC]



# 1.1.1 Java语言发展史

Oak由于该名字已被注册后改名为java

# 1.1.2 Java语言平台版本

## Java Development Kit

1995年5月23日，Java语言诞生

1996年1月，第一个JDK-JDK1.0诞生

1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术

1996年9月，约8.3万个网页应用了JAVA技术来制作

1997年2月18日，JDK1.1发布

1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录

1997年9月，JavaDeveloperConnection社区成员超过十万

1998年2月，JDK1.1被下载超过2,000,000次

1998年12月8日，JAVA2企业平台J2EE发布

1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）

2000年5月8日，JDK1.3发布

2000年5月29日，JDK1.4发布

2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机

2001年9月24日，J2EE1.3发布

2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升

2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0

2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字"2"：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME

2006年12月，SUN公司发布JRE6.0

2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。

2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。

2011年7月28日，甲骨文发布java7.0的正式版。

2014年3月18日，Oracle公司发表Java SE 8。

## Java语言平台版本

J2SE(Java 2 Platform Standard Edition)标准版

该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。

J2EE(Java 2 Platform Enterprise Edition)企业版

是为开发企业环境下的应用程序提供的一套解决方案，该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发。

J2ME(Java 2 Platform Micro Edition)小型版

是为开发电子消费产品和嵌入式设备提供的解决方案。

# 1.1.3 Java语言特点

简单性、解释性、面向对象、高性能、分布式处理、多线程、**健壮性**、安全性。

开源跨平台（因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。也称为Java具有良好的可移植性）

# 1.1.4 JRE与JDK

## 1. 定义

Jre是java运行环境，而不是开发者，包括java虚拟机和java平台核心类和支持文件，不包含开发工具，调试器、编译器等。

Jdk是java开发工具包，提供java开发环境，（提供了编译器 javac 等工具，用于将java文件编译成class文件）和运行环境（提供了jvm和runtime辅助包用于解析class文件使其运行）

Jdk包含jre，是整个java的核心

## 2、区别

JRE 主要包含：java 类库的 class 文件(都在 lib 目录下打包成了 jar)和虚拟机(jvm.dll)；JDK 主要包含：java 类库的 class文件(都在 lib 目录下打包成了 jar)并自带一个 JRE。那么为什么 JDK 要自带一个 JRE 呢？而且 jdk/jre/bin 下的 client 和 server 两个文件夹下都包含 jvm.dll(说明 JDK 自带的 JRE 有两个虚拟机)。

JavaSE 可以开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。是EE，和ME的基础。

JavaEE 前端开发，使用于动态开发网页制作。

JavaME 适用于安卓开发。

# 1.1.5 JAVA核心机制与JVM运行原理

## 1.Java语言运行的过程

Java语言写的源程序通过Java编译器，编译成与平台无关的‘字节码程序’(.class文件，也就是0，1二进制程序)，然后在OS之上的Java解释器中解释执行。           

注：JVM（java虚拟机）包括解释器，不同的JDK虚拟机是相同的，解释器不同。

## 2.JVM：

Jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。

Java编译器只要面向JVM，生成JVM能理解的代码或字节码。

JVM执行程序的过程：加载.class文件->管理并分配内存->执行垃圾收集

# 1.2.1 JDK安装与配置

JAVA_HOME：jdk的目录  E:\Java\jdk1.8.0_161

Path后面加              %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;

新建CLASSPATH变量  .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar

# 1.2.4 JAVA程序运行原理

*.java→*.class→机器码->java编译器 (编译) → 虚拟机(解释执行) →  解释器(翻译) → 机器码

Java中，类加载器把一个类装入JAVA虚拟机需要经过三个步骤来完成：装载、链接、初始化，其中链接又分来校验、准备、解析过程

装载：查找和导入.class文件。

链接：检查装入.class文件的正确性，然后，java虚拟机为变量分配内存，设置默认值。

初始化：把符号引用变成直接引用。

# 1.3.2 常量、变量内存空间分配与原理

1、栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、堆区（heap）由程序员分配释放，若程序员不释放，程序借宿时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

3、全局区（静态区）（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

4、文字常量区—常量字符串就是放在这里的，程序结束后由系统释放。

5、程序代码区—存放函数体的二进制代码。

```java
int a = 0; 全局初始化区 

char *p1; 全局未初始化区 

main() 

{ 

int b; 栈 

char s[] = "abc"; 栈 

char *p2; 栈 

char *p3 = "123456"; 123456\0在常量区，p3在栈上。 

static int c =0； 全局（静态）初始化区 

p1 = (char *)malloc(10); 

p2 = (char *)malloc(20); 

分配得来得10和20字节的区域就在堆区。 

strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 

}
```

# 1.3.5 运算符与表达式

Int x=5;

Int y=++x;  y的值为6

Int y=x++;   y的值为5，x的值为6

# 1.3.7 标识符与关键字

  Java    中的名称命名规范  

​    （    1    ）包名：多单词组成时所有字母都小写：    xxxyyyzzz  

​    （    2    ）类名、接口名：多单词组成时，所有单词的首字母大写：    XxxYyyZzz  

​    （    3    ）变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：    xxxYyyZzz  

​    （    4    ）常量名：所有字母都大写。多单词时每个单词用下划线连接：    XXX_YYY_ZZZ  

# 1.4.6 特殊流程控制结构

  Break    ：终止循环；      Continue    ：结束本次循环，进入下一次循环；      return    ：结束程序，返回结果；    注意：Break和Continue二者是适用于循环中

# 1.5.1 数组概述及作用（P1，P2）

  数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。  

  集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用  。

# 1.5.3 数组的初始化与内存分析

  初始化的两种方式：  

  静态初始化：初始化时由我们自己指定每个数组元素的初始值，由系统决定需要的数组长度；  

  格式：数组名     = new     数组类型    []{    元素    1,    元素    2,    元素    3...    元素    n};   a1 = new  int{1,2,3,4,5};  

  简化语法：数组名     = {    元素    1,    元素    2,    元素    3...    元素    n};                      a1 =  {1,2,3,4,5};  

  动态初始化：初始化时由我们指定数组的长度，由系统为数组元素分配初始值；  

  格式：数组名     = new     数组类型    [    数组长度    ];                          a1 = new int[ 8];  

# 1.6.3方法调用的过程分析

  假设调用    x.f(args)    ，隐式参数    x    声明为类    C    的一个实例对象：  

  1.    编译器查看对象的声明类型和方法名。例如，可能存在方法    f(int)    和方法    f(String)    。编译器将会一一列举出所有该类中名为    f    的方法和其超类中访问属性为    public    且名为    f    的方法。  

  2.    编译器将查看调用方法时提供的参数类型。如果在所有名为    f    的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程称为重载解析。  

  3.    如果是    private    方法、    static    方法、    final    方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种方法称为静态绑定。与此对应的，调用的方法依赖于隐式参数的实际类型，并且在运行时才动态绑定。  

  4.    当程序运行时，并且采用动态绑定的方式，虚拟机一定调用与    x    所引用对象的实际类型最合适的那个类的方法。假设    x    的实际类型为    D    ，它是    C    类的子类。如果    D    类定义了方法    f(String)    ，就直接调用它；否则，在其父类中找到    f(String)    ，以此例推。每次调用方法，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。在真正调用方法时，虚拟机仅仅查找这个表。  

  虚拟机运行过程：  

  调用    e.getSalary()    的解析过程：  

  1.    首先，虚拟机提取    e    的实际类型的方法表。  

  2.    虚拟机搜索定义    getSalary    签名的类。  

  3.    虚拟机调用方法。  

# 1.7.2 类和对象

  类是一种抽象的概念集合，是最基础的组织单位，作为对象的模板、合约或蓝图。  

  类是对象的类型，使用一个通用类可以定义同一类型的对象，类中定义对象的数据域是什么以及方法是做什么的。     对象是类的实例，一个类可以拥有多个实例，创建实例的过程叫做实例化。实例也称为对象，两者说法一致  

# 1.7.4 Java内存管理与垃圾回收

## Java运行时内存区域

  Java    运行时内存区域如图    2-1    所示，内存区域逻辑上被划分为：程序计数器，栈，本地方法栈，堆，方法区。其中程序计数器，栈，本地方法栈都是线程私有的，堆和方法区被所有线程共享。  

  程序计数器用于指示当前线程执行的字节码的行号；栈用于描述    Java    方法执行的内存模型，每当进入一个新的方法，    JVM    都会在栈中创建一个栈帧（存放本地变量，参数，返回地址，操作数栈）；本地方法栈是本地方法执行的内存模型，    HotSpot    虚拟机将栈和本地方法栈合二为一。  

​         在提及到栈的时候，我们需要涉及两个异常：    StackOverflowError    和    OutOfMemoryError    ，这两个异常的区别在于：当线程请求的栈深度超过虚拟机允许的栈深度时，会抛出    StackOverflowError    ；当虚拟机无法为线程扩展栈分配足够的空间时，会抛出    OutOfMemoryError    。  

​         设置栈深度的示例：    -Xss128k    ==>>       设置栈的深度为    128KB  

  下面我们来看一下另一块非常重要的区域：堆，    Java    堆是用于存放    Java    对象实例的主要区域，通过    new    ，    clone    ，反序列化创建的对象都存放在堆中，为什么    Java    要把对象存放在堆中，而不是栈中呢？  

​         C++    由于没有垃圾回收机制，所以当定义一个变量时，其内存是在栈中分配的，只有通过    new    显式的创建一个对象时，对象才会从堆中分配内存，并且此时需要通过    delete    显式的释放对象占用的内存，否则会造成内存泄露。    Java    中除了基本类型变量（    boolean, byte, char, short, int, long, float, double    ），其他类型的变量基本都是通过    new    来创建，所以其内存都是从堆中分配，当对象废弃时，垃圾收集器会自动回收这部分内存。由于堆是各个线程共享的内存区域，所以把对象存放在堆中有利于线程之间的通信（共享内存）。正如之前我们在描述栈时所看到的，    JVM    会为每个方法创建一个栈帧，所以如果对象存放在栈中，方法调用的参数将需要从调用方法的栈帧拷贝到被调用方法的栈帧，如果对象存放在堆中，只需要拷贝指针或引用（此时，两个方法将指向同一个对象）。所以我们可以认为    Java    之所以把对象存放在堆中，其一是    Java    具有非常优秀的垃圾回收机制，其二把对象存放在堆中有利于线程之间共享数据及通信，其三是可以减少不必要的对象拷贝，提升方法调用的效率，同时也节约了内存。  

​         因为不同的    Java    对象生命周期可能不同，所以基于    Java    对象不同的生命周期，堆被分成了两个不同的区域：新生代和老年代，新生代中对象的生命周期短，存活率低，老年代中对象的生命周期长，存活率高。基于不同的存活率，这两个区域的垃圾收集也采用了不同的算法，新生代一般采用复制算法，老年代一般采用标记    -    删除或标记    -    整理算法。复制算法就是将存活下来的对象从一个区域复制到另一个区域，标记删除和标记整理就是将需要回收的对象标记出来，然后清除掉，标记整理算法还会对内存进行整理，这样可以避免内存碎片。将    Java    堆分成两个不同的年代并采用不同回收算法的垃圾收集方式被称为分代收集。下一节将详细介绍垃圾收集的机制以及常用垃圾收集器。  

  介绍完    Java    堆之后，我们来看一下方法区，方法区是用于存放类信息、常量（    final, static final    ）、静态变量    (static)    、即时编译器编译后的代码的地方。    HotSpot    虚拟机把这部分区域称为永久代，因为    HotSpot    虚拟机把分代收集扩展到了方法区，或者我们可以说    HotSpot    虚拟机通过永久代来实现方法区；同时提供了参数    -XX:MaxPermSize    来限制方法区的最大内存。但其实这并不是一个很好的选择，当加载的类比较多或者常量池比较大时，很容易导致内存溢出。目前    HotSpot    官方团队已经在逐步采用本地内存实现方法区，    JDK1.7    已经将常量池移出永久代。当该区域的内存无法满足要求时，也会导致内存溢出。  

## 垃圾回收

  根据前面对运行时内存区域的描述，我们知道垃圾回收主要集中在堆和方法区，方法区可以选择性实现垃圾回收，该区域的垃圾回收主要集中在回收废弃常量和类型卸载。前面我们已经提及了复制算法和标记整理算法，那在此之前我们如何知道哪些对象时废弃的，哪些对象时不能回收的呢？对于具备垃圾回收功能的语言，一般采用两种算法确定废弃对象：引用计数法（    Python    ）和可达性分析算法（也被称为根搜索算法，    C#    ，    Lisp    ），    Java    采用可达性分析算法。引用计数法通过跟踪对象的引用计数器来确定对象是否被废弃，当一个新的引用指向该对象时，引用计数加    1    ，当一个引用不在指向该对象时，引用计数减    1    ，当引用计数为    0    时，对象被废弃。该算法在遇到堆中两个对象循环引用时（即对象    A    中有一个字段指向对象    B    ，对象    B    中有一个字段指向    A    ），会导致内存泄露，即这部分内存永远不会被回收，因为这两个对象的引用计数永远不为    0    。该算法出现问题的原因在于没有区分指向对象的引用    ref    的来源，假如    ref    位于栈或者方法区中，说明该对象没有废弃；但假如    ref    位于堆中，则不能确定，此时我们可以继续判断指向    ref    所在对象的引用    ref2    所在的内存区域，通过这种方法不断回溯，如果最终可以到达栈，本地方法栈或者方法区中，则说明引用链中的对象都是没有废弃的，否则都是废弃的，这就是可达性分析算法。  

​        Java    除了通过可达性分析算法判断哪些对象需要回收之外，还提供了不同的引用级别用于实现更加灵活的垃圾回收。    Java    一共提供了四种引用级别：强引用，软引用    (SoftReference)    ，弱引用    (WeakReference)    ，虚引用    (PhantomReference)    。强引用就是我们一般的引用方式，软引用指向对象在系统将要发生内存溢出时会被回收（可以用于实现缓存），弱引用指向的对象会在下一次垃圾回收时被回收，虚引用指向的对象只是会在垃圾回收时收到一个系统通知，对象的生命周期完全不会受虚引用的影响。  

​         下面我们来看一下复制算法    (Copy)    和标记    -    整理    (Mark-Compact)    算法的具体实现，其实这两个算法都是从标记    -    清除（    Mark-Sweep    ）算法改进而来的，标记清除算法会遇到两个问题：第一个问题是效率问题，当对象存活率很低时，其实把存活对象找出来并整理到一个区域，效率会更高，这就是复制算法；第二个问题是当存活率比较高时，会出现内存碎片问题，所以出现了标记    -    整理算法。    Java    堆采用了新生代为复制算法，老年代为标记    -    整理或标记    -    清除算法的分代收集机制。  

   ![1566480048617](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\1566480048617.png)

  图    2-2            标记清楚算法  

   ![1566480056362](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\1566480056362.png)

  图     2-3           复制算法  

   ![1566480061499](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\1566480061499.png)

  图    2-3       标记     -     整理算法  

 

​         复制算法将新生代分成    Eden    ，    From Survivor    ，    To Survivor    三块区域，每次垃圾收集    Eden    ，    From Survivor    中存活的对象都会被复制到    To Survivor    中。记住，这三个区域的划分只是逻辑上的，和物理划分无关，默认    Eden    和    Survivor    的大小比例为    8 : 1    ，比例划分这么大是为了提高内存的利用率，在这种比例下可利用的内存其实只有    90%    ；看到这里，我想很多人可能会问，假如    10%    的空间不够存放生存下来的对象怎么办？    JVM    提供了一种被称为分配担保（    Handle Promotion    ）的机制，由老年代为    To Survivor    空间提供担保，假如    To Survivor    没有足够的空间存放生存下来的对象，这些对象直接存放到老年代，假如老年代还不够存放，就会抛出    OutOfMemoryError    异常。  

​         分析了垃圾收集算法的思想之后，我们来了解一下常用的垃圾收集器，新生代的垃圾收集器包括     Serial    ，    ParNew    ，    Parallel Scavenge    ，老年代的垃圾收集器包括    Serial Old    ，    CMS    ，    ParOld    。这些垃圾收集器的一个区别是单线程还是多线程，其中    Serial    ，    Serial Old    是单线程的，其余是多线程的；第二个区别是垃圾收集线程和用户线程是否可以并发执行，    CMS    收集器可以分成初始标记，并发标记，重新标记，并发回收等过程，其中并发标记和并发回收可以与用户线程并发执行，所以它也是这些垃圾收集器中唯一真正意义上的并发收集器；    Parallel Scavenge    与    ParOld    以提高吞吐量为目的，其他收集器以减小停顿时间（    Stop The World    ）为目的。  

## 创建对象及内存分配

  前面提到，    Java    创建对象的方式包括    new    、    clone    、    deserialization    ，在虚拟机内部，这三种创建对象的方式其实是相同的。首先寻找或加载类信息，如果无法正常加载，则抛    ClassNotFoundException    ，否则到    java    堆中分配内存，分配内存的方式根据内存是否规整（取决于垃圾回收算法，标记整理和复制算法的内存都是规整的，标记清除的内存不规整）有两种方式：指针碰撞和空闲列表。指针碰撞的方式中通过指针    ptr    将内存分成两个部分，    ptr    之前的部分都被使用，    ptr    之后的部分是空闲的，当对象需要的内存为    size    时，指针    ptr = ptr + size    。空闲列表是通过将空闲的区域通过链表连接起来，对象需要内存则遍历链表，直到遇到一个具有足够空间的元素为止。内存分配完之后就将所分配的内存初始化为    0    ，每个对象都有一个对象头，这里保存着和对象相关的锁，对象的哈希码，对象的    GC    分代年龄，以及指向方法区中类型的相关引用。到此为止，对于虚拟机来说，已经成功创建了一个对象；但从    Java    程序来说，这才刚刚开始，接下来会执行    <init>    方法对所有字段进行初始化。  

​        对于不同的对象，所分配的内存的区域是不同的。一般来说，优先在    Eden    空间中分配内存；对于大对象，优先在老年代中分配内存（    size    大于    PrenureSizeThreshold    ）；当对象的年龄大于    MaxTenuringThreshold    时，对象也会被移动至老年代；如果    Survivor    空间中相同年龄的所有对象大小总和大于    Survivor    空间的一半，年龄大于或等于该年龄的对象直接进入老年代。  

# 1.7.8 this关键字

## 构造方法中的this关键字

  1)        只能在构造方法中通过    this    来调用其他构造方法，普通方法中不能使用。   

  2)        不能通过    this    递归调用构造方法，即不能在一个构造方法中通过    this    直接或间接调用该构造方法本身。  

  3)     通过    this    调用其他构造方法必须放在构造方法的第一行中执行。由于    super    调用父类的构造函数也必须放在构造方法的第一行中执行，因此，通过    this    和    super    调用构造方法不能同时出现一个构造方法中。也不能在一个构造方法中多次调用不同的构造方法。  

 

  在构造方法中也可以使用    this    关键字来访问本类中的成员变量和成员函数。其用法和非构造方法中的    this    关键字相同。  

## 非构造方法中的this关键字

  在    Java    中可以通过通过    this    关键字来调用类中的成员变量和方法。其用法是。   

  1) this.xxx;     访问类中的成员变量    xxx   

  2) this.yyy(paras…);     访问类中的成员方法    yyy   

  3) this;     当前类对象的引用   

  this    关键字访问类的成员变量和成员函数时不受访问权限的控制，可以访问本类中所有的成员变量和方法，包括    private    的成员变量和方法。也可以通过    this    访问本类的    static    成员，不过由于    static    成员可以通过类名直接访问，如果通过    this    来访问会有    “The static field ××× should be accessed in a static way”    的警告信息。不能在类的    static    成员或    static    块中使用    this    。  

## 继承关系下的this关键字

  在继承关系下，父类中的    this    关键字并不总是表示父类中的变量和方法。    this    关键字的四种用法如前文所述，列举如下。   

  1) this(paras…);     访问其他的构造方法   

  2) this.xxx;     访问类中的成员变量    xxx   

  3) this.yyy(paras…);     访问类中的成员方法    yyy   

  4) this;     当前类对象的引用   

  对第一种，无论子类是否有相同参数的构造方法，    this(paras…);    访问的始终是父类中的构造方法。   

  对第二种，无论子类是否有覆盖了该成员变量，    this.xxx;    访问的始终是父类中的成员变量。   

  对第三种，如果子类重写了该成员方法，则    this.yyy(paras…);    访问的是子类的成员方法，如果子类没有重写该成员方法，则    this.yyy(paras…);    访问的是父类的成员方法。   

  对第四种，    this    始终代表的是子类的对象。        

# 1.7.12 Java代码块

  静态代码块：用    staitc    声明，    jvm    加载类时执行，仅执行一次     构造代码块：类中直接用    {}    定义，每一次创建对象时执行。     执行顺序优先级：静态块    ,main(),    构造块    ,    构造方法。  

  对于一个类而言，按照如下顺序执行：               

  1.         执行静态代码块  

  2.         执行构造代码块  

  3.         执行构造函数     

  对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）    >    （变量、初始化块）    >    构造器。  

  当涉及到继承时，按照如下顺序执行：  

  1.         执行父类的静态代码块，并初始化父类静态成员变量  

  2.         执行子类的静态代码块，并初始化子类静态成员变量  

  3.         执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量  

  4.         执行子类的构造代码块，     执行子类的构造函数，并初始化子类普通成员变量  

# 1.7.14 方法重写 Override

## 方法的重写规则

  1.          参数列表必须完全与被重写方法的相同；  

  2.          返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（    java5     及更早版本返回类型要一样，    java7     及更高版本可以不同）；  

  3.          访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为    public    ，那么在子类中重写该方法就不能声明为    protected    。  

  4.          父类的成员方法只能被它的子类重写。  

  5.          声明为    final    的方法不能被重写。  

  6.          声明为    static    的方法不能被重写，但是能够被再次声明。  

  7.          子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为    private    和    final    的方法。  

  8.          子类和父类不在同一个包中，那么子类只能够重写父类的声明为    public    和    protected    的非    final    方法。  

  9.          重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。  

  10.       构造方法不能被重写。  

  11.       如果不能继承一个方法，则不能重写这个方法。  

## 重载规则:

  1.          被重载的方法必须改变参数列表    (    参数个数或类型不一样    )    ；  

  2.          被重载的方法可以改变返回类型；  

  3.          被重载的方法可以改变访问修饰符；  

  4.          被重载的方法可以声明新的或更广的检查异常；  

  5.          方法能够在同一个类中或者在一个子类中被重载。  

  6.          无法以返回值类型作为重载函数的区分标准。  

# 1.7.15 多态

  指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。  

  多态性就是相同的消息使得不同的类做出不同的响应  。

  Java    实现多态有三个必要条件：继承、重写、向上转型。  

# 1.8.3 String类、StringBuffer类、StringBuilder类

  String    类型声明之后不可以变。  

  StringBuffer    声明之后还可以更改。  

  StringBuilder    类和    StringBuffer    类一样，但是    StringBuffer    比较安全但是运行比较慢，    StringBuilder    运行比较块。  

# 基本类型包装类(Integer,Character等)

  基本数据类型       包装类     取值范围        占用字符  

  byte     Byte          -128~127       占用一个字节  

  short   Short         -32768~32767      占用两个字节  

  int  Integer            -2147483648~2147483647     占用四个字节  

  long     Long              占用    8    个字节  

  float     Float              占用    4    个字节  

  double Double          占用    8    个字节  

  char     Character      占用    2    个字节  

  boolean     Boolean  

  包装类     包装类转基本类型      基本类型转包装类  

  Byte    Byte.valueOf(byte)     byteInstance.byteValue()  

  Short  Short.valueOf(short)  shortInstance.shortValue()  

  Integer      Integer.valueOf(int)    integerInstance.intValue()  

  Long   Long.valueOf(long)    longInstance.longValue()  

  Float   Float.valueOf(float)    floatInstance.floatValue()  

  Double      Double.valueOf(double)   doubleInstance.doubleValue()  

  Character Character.valueOf(char)   charInstance.charValue()  

  boolean    Boolean.valueOf(booleann)   booleanInstance.booleanValue()  

# 1.8.8 Date类、DateFormat类、Calendar类

  Date    获取当前时间  

  DateFormat     Date    类获取的时间是以默认的英文格式输出日期和时间    .DateDateFormat    类专门用于将日期格式化为字符串或者特定格式显示的字符串转换成一个    Date    对象。  

  Calendar       获取时间对象  

  SimpleDateFormat     可以使用     SimpleDateFormat     来对日期时间进行格式化，如可以将日期转换为指定格式的文本，也可将文本转换为日期。  

# 1.9.1 Java异常处理机制

## 一、Throwable类

   先从    Java    异常类继承关系      最顶级    Throwable    类说起：  

  1.Throwable     可抛出的（是    Object    的子类）。  

  2.Throwable     类是     Java     语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过     Java     虚拟机或者     Java throw     语句抛出。类似地，只有此类或其子类之一才可以是     catch     子句中的参数类型。   

  3.    两个子类的实例，    Error     和     Exception    ，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息（比如堆栈跟踪数据）。  

  4.Throwable    类中的常用方法  

  注意：    catch    关键字后面括号中的    Exception    类型的参数    e    。    Exception    就是    try    代码块传递给    catch    代码块的变量类型，    e    就是变量名。    catch    代码块中语句    "e.getMessage();"    用于输出错误性质。通常异常处理常用    3    个函数来获取异常的有关信息    :  

​       getCause()    ：返回抛出异常的原因。如果     cause     不存在或未知，则返回     null    。  

　   printStackTrace()    ：对象的堆栈跟踪输出至错误输出流，作为字段     System.err     的值。  

​       public String getMessage()     返回此     throwable     的详细消息字符串。  

  5.Error    和    Exception    区别  

​    Error      是不可修复、不可捕获的、致命的；一般是与编译器相关的问题，如系统崩溃、虚拟机错误、动态链接库失败等。     Java    虚拟机（    JVM    ）一般会选择线程终止  

​    Exception     是可以避免的；    java.lang.Exception    类是    Java    中所有异常的直接或间接父类。即    Exception    类是所有异常的根类。  

  注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  

  Java    中的异常分为两大类：  

　　  1.Checked Exception    （检查型异常）  

　　  2.Unchecked Exception    （    Runtime Exception    ）非可检查型  

# 1.9.2 使用try..catch..finally处理异常

  在不抛出异常的情况下，程序执行完     try     里面的代码块之后，该方法并不会立即结束，而是继续试图去寻找该方法有没有     finally     的代码块，     如果没有     finally     代码块，整个方法在执行完     try     代码块后返回相应的值来结束整个方法；     如果有     finally     代码块，此时程序执行到     try     代码块里的     return     语句之时并不会立即执行     return    ，而是先去执行     finally     代码块里的代码，     若     finally     代码块里没有     return     或没有能够终止程序的代码，程序将在执行完     finally     代码块代码之后再返回     try     代码块执行     return     语句来结束整个方法；     若     finally     代码块里有     return     或含有能够终止程序的代码，方法将在执行完     finally     之后被结束，不再跳回     try     代码块执行     return    。  

# 1.10.2 Collection接口

## 1、Collection接口

​         Collection    是最基本集合接口，它定义了一组允许重复的对象。    Collection    接口派生了两个子接口    Set    和    List    ，分别定义了两种不同的存储方式，如下  

  2    、     Set    接口  

​         Set    接口继承于    Collection    接口，它没有提供额外的方法，但实现了    Set    接口的集合类中的元素是无序且不可重复。  

​         特征：无序且不可重复。  

  3    、      List    接口  

​          List    接口同样也继承于    Collection    接口，但是与    Set    接口恰恰相反，    List    接口的集合类中的元素是对象有序且可重复。  

​         特征：有序且可重复。  

​         两个重的实现类：    ArrayList    和    LinkedList  

​         1.ArrayList    特点是有序可重复的  

​         2.LinkedList    是一个双向链表结构的。  

  4    、    Map    接口  

​         Map    也是接口，但没有继承    Collection    接口。该接口描述了从不重复的键到值的映射。    Map    接口用于维护键    /    值对（    key/value pairs    ）。  

​         特征：它描述了从不重复的键到值的映射。  

​         两个重要的实现类：    HashMap    和    TreeMap  

​         1.HashMap    ，中文叫散列表，基于哈希表实现，特点就是键值对的映射关系。一个    key    对应一个    Value    。    HashMap    中元素的排列顺序是不固定的。更加适合于对元素进行插入、删除和定位。  

​         2.TreeMap    ，基于红黑书实现。    TreeMap    中的元素保持着某种固定的顺序。更加适合于对元素的顺序遍历。  

  5    、    Iterator    接口  

​         Iterator    接口，在    C#    里有例外一种说法    IEnumerator    ，他们都是集合访问器，用于循环访问集合中的对象。  

​        所有实现了    Collection    接口的容器类都有    iterator    方法，用于返回一个实现了    Iterator    接口的对象。    Iterator    对象称作迭代器，    Iterator    接口方法能以迭代方式逐个访问集合中各个元素，并可以从    Collection    中除去适当的元素。  

  <span style="font-size:10px;">Iterator it = collection.iterator(); //     获得一个迭代子    

  while(it.hasNext())     

  {    

  Object obj = it.next(); //     得到下一个元素    

  } </span>  

  6    、    Comparable    接口  

​        Comparable    可以用于比较的实现，实现了    Comparable    接口的类可以通过实现    comparaTo    方法从而确定该类对象的排序方式。  

  总结  

​         Collection    集合分别派生自    Collection    和    Map    接口，    Collection    有两个常用子接口    List    和    Set    ，分别表示有序可重复，无序不可重复的集合。而    Map    存储的是    key-value    的映射。  

​          上面的总结看上去很多，很繁琐，其实你只要记得一点：    collection    是用于处理各种数据结构的，根据各种数据结构的特点理解，一切都会变简单。  

  。这种情况通常可以用这个虚拟节点直接表示这个链表。  

# d1.10.3 List接口及实现类（ArrayList、LinkedList）

  区别如下：  

  ArrayList    内部存储的数据结构是数组存储。数组的特点：元素可以快速访问。每个元素之间是紧邻的不能有间隔，缺点：数组空间不够元素存储需要扩容的时候会开辟一个新的数组把旧的数组元素拷贝过去，比较消性能。从    ArrayList    中间位置插入和删除元素，都需要循环移动元素的位置，因此数组特性决定了数组的特点：适合随机查找和遍历，不适合经常需要插入和删除操作。  

  Vector    内部实现和    ArrayList    一样都是数组存储，最大的不同就是它支持线程的同步，所以访问比    ArrayList    慢，但是数据安全，所以对元素的操作没有并发操作的时候用    ArrayList    比较快。  

  LinkedList    内部存储用的数据结构是链表。链表的特点：适合动态的插入和删除。访问遍历比较慢。另外不支持    get    ，    remove    ，    insertList    方法。可以当做堆栈、队列以及双向队列使用。    LinkedList    是线程不安全的。所以需要同步的时候需要自己手动同步，比较费事，可以使用提供的集合工具类实例化的时候同步：具体使用    List<String> springokList=Collections.synchronizedCollection(new     需要同步的类    )    。  

  总结  

  1.    内部存储结构区别：  

   ArrayList    、    Vector    是数组存储。    LinkedList    是链表存储。  

  2.    线程安全区别：  

  ArrayList    、    LinkedList    线程不安全。    Vector    线程安全。  

  3.    使用场景区别：  

  使用线程同步的时候    Vector    类首选或者使用    Collections    工具类初始化时候同步。  

  需要经常删除、增加使用    LinkedList(    链表结构    )    、经常需要查询迭代使用    ArrayList(    数组结构    )  

# 1.10.4 Set接口及实现类（HashSet、TreeSet）

  HashSet    它不保证迭代顺序，特别是它不保证该顺序恒久不变。如果我们想要元素迭代顺序与添加顺序相同，那么我们可以使用    HashSet    的子类    java.util.LinkedHashSet<E> 。

  TreeSet    和    hashSet    用法一样  

# 1.10.5 Map接口及实现类（HashMap、ConcurrentHashMap）

## 一、HashMap和TreeMap区别

​        1    、    HashMap    是基于散列表实现的，时间复杂度平均能达到    O(1)    。     TreeMap    基于红黑树（一种自平衡二叉查找树）实现的，时间复杂度平均能达到    O(log n)    。  

​       2    、    HashMap    、    TreeMap    都继承    AbstractMap    抽象类；    TreeMap    实现    SortedMap    接口，所以    TreeMap    是有序的！    HashMap    是无序的  

​       3    、两种常规    Map    性能               HashMap    ：适用于在    Map    中插入、删除和定位元素。               Treemap    ：适用于按自然顺序或自定义顺序遍历键    (key)    。  

​       4.    总结  

​         HashMap    通常比    TreeMap    快一点    (    树和哈希表的数据结构使然    )    ，建议多使用    HashMap    ，在需要排序的    Map    时候才用    TreeMap    。  

## 二、HashMap和Hashtable的区别

​        HashMap    和    Hashtable    都实现了    Map    接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步    (synchronization)    ，以及速度。  

​        HashMap    几乎可以等价于    Hashtable    ，除了    HashMap    是非    synchronized    的，并可以接受    null(HashMap    可以接受为    null    的键值    (key)    和值    (value)    ，而    Hashtable    则不行    )    。     HashMap    是非    synchronized    ，而    Hashtable    是    synchronized    ，这意味着    Hashtable    是线程安全的，多个线程可以共享一个    Hashtable    ；而如果没有正确的同步的话，多个线程是不能共享    HashMap    的。    Java 5    提供了    ConcurrentHashMap    ，它是    HashTable    的替代，比    HashTable    的扩展性更好。     另一个区别是    HashMap    的迭代器    (Iterator)    是    fail-fast    迭代器，而    Hashtable    的    enumerator    迭代器不是    fail-fast    的。所以当有其它线程改变了    HashMap    的结构（增加或者移除元素），将会抛出    ConcurrentModificationException    ，但迭代器本身的    remove()    方法移除元素则不会抛出    ConcurrentModificationException    异常。但这并不是一个一定发生的行为，要看    JVM    。这条同样也是    Enumeration    和    Iterator    的区别。     由于    Hashtable    是线程安全的也是    synchronized    ，所以在单线程环境下它比    HashMap    要慢。如果你不需要同步，只需要单一线程，那么使用    HashMap    性能要好过    Hashtable    。     HashMap    不能保证随着时间的推移    Map    中的元素次序是不变的。      我们能否让    HashMap    同步？     HashMap    可以通过下面的语句进行同步：  

  Map m = Collections.synchronizeMap(hashMap);  Hashtable    继承自    Dictionary    类，而    HashMap    是    Java1.2    引进的    Map interface    的一个实现    .  

### 三、HashSet和HashMap的区别

​        HashSet    是基于    HashMap    实现的。  

## 四、ConcurrentMap 

  ConcurrentHashMap     表现区别：不可以有    null    键，线程安全，原子操作。一个    ConcurrentHashMap     由多个    segment     组成，每个    segment     包含一个    Entity     的数组。这里比    HashMap     多了一个    segment     类。该类继承了    ReentrantLock     类，所以本身是一个锁。当多线程对    ConcurrentHashMap     操作时，不是完全锁住    map    ，     而是锁住相应的    segment     。这样提高了并发效率。缺点：当遍历    ConcurrentMap    中的元素时，需要获取所有的    segment     的锁，使用遍历时慢。锁的增多，占用了系统的资源。使得对整个集合进行操作的一些方法  

## 五、LinkedHashMap是HashMap的一个子类

  LinkedHashMap    保存了记录的插入顺序，在用    Iterator    遍历    LinkedHashMap    时，先得到的记录肯定是先插入的    .    也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比    HashMap    慢，不过有种情况例外，当    HashMap    容量很大，实际数据较少时，遍历起来可能会比    LinkedHashMap    慢，因为    LinkedHashMap    的遍历速度只和实际数据有关，和容量无关，而    HashMap    的遍历速度和他的容量有关。  

  六、    java    为数据结构中的映射定义了一个接口    java.util.Map;    它有四个实现类    ,    分别是    HashMap Hashtable LinkedHashMap     和    TreeMap.   

# 1.10.6 Collections工具类

  Collections.sort    ：排序。  

  Collections.shuffle    ：混合排序。  

  Collections.reverse    ：反转。  

# 1.10.7 Arrays工具类

  Arrays.asList    ：将数组转换成    list    类型，这个    list    的长度是固定的不可以添加或删除。  

  Arrays.sort    ：对数组进行排序。  

  Arrays.copyOf    ：数组拷贝。    Arrays.copyOf(str, str.length);  

  Arrays.copyOfRange    ：数组拷贝，指定范围。    Arrays.copyOfRange(str,1,3);  

  Arrays.fill    ：给数组赋值。  

  Arrays.deepToString:    当数组中包含数组时，需要用    deepToString    。  

# 1.10.8 Iterator接口 Enumeration

## 1）两者的函数接口不同

  //Enumeration    指定下面的两个方法：   

  //    当仍有更多的元素可提取时返回    true;    当所有元素都被枚举了，则返回    false  

  boolean hasMoreElements();  

  //    将枚举中的下一个对象做为一个类属     Object    的引用而返回  

  Object nextElement() ;  

  //Iterator    接口中定义了三个方法    :  

  //    是否还有下一个元素  

  hasNext();  

  //    返回下一个元素  

  next();  

  //    删除当前元素  

  remove();  

  //    需要注意的是，调用    next()    方法后才可以调用    remove()    方法  

  //    而且每次调用    next()    后最多只能调用一次    remove()    方法    ,    否则抛出    IllegalStateException    异常  

## 2）Iterator支持fail-fast机制，而Enumeration不支持

  Enumeration     是    JDK 1.0    添加的接口。使用到它的函数包括    Vector    、    Hashtable    等类，     Enumeration    存在的目的就是为它们提供遍历接口，    Enumeration    本身并没有支持同步，而在    Vector    、    Hashtable    实现    Enumeration    时，添加了同步。  

  Iterator     是    JDK 1.2    才添加的接口，它也是为了    HashMap    、    ArrayList    等集合提供遍历接口。    Iterator    是支持    fail-fast    机制的。  

  fail-fast     机制是指    Java    集合    (Collection)    中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生    fail-fast    事件。例如：当某一个线程    A    通过    iterator    去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程    A    访问集合时，就会抛出    ConcurrentModificationException    异常，产生    fail-fast    事件。  

# 1.10.9 泛型类、泛型方法、泛型接口

## 定义泛型

  Java    在接口、类或类的方法的声明中，声明一个泛型。多个参数时要用逗号隔开。  泛型的  声明需要写在接口名、类名之后，方法的返回值之前。  

定义时要注意三点：    1.     泛型的类型参数只能是引用类型，不能是基本类型。      2.     使用尖括号     <>     声明一个泛型。      3. <>    里可以使用    T    、    E    、    K    、    V    等字母。这些对编译器来说都是一样的，可以是任意字母。只是程序员习惯在特定情况下用不同字母来区分：  

  T     ：     Type     （类型）   

  E :  Element    （元素）   

  K     ：     Key    （键）   

  V     ：     Value    （值）  

  包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参，从而可以动态生成无数个逻辑上的子类，但这种子类在物理上并不存在。  

## 泛型方法

  1    ）泛型方法的定义  

  修饰符     <    声明自定义泛型    >     返回值类型     方法名    (    形参列表    ) {  

​      ...  

  }  

## 2）泛型方法要注意的事项

  A.     泛型方法的定义和普通方法定义不同的地方在于，需要在修饰符和返回类型之间加一个泛型类型参数的声明，表明在这个方法作用域中谁才是泛型类型参数。  

  B.     类型参数的作用域   

  class A<T> { ... }    中    T    的作用域就是整个    A    ；   

  public <T> func(...) { ... }    中    T    的作用域就是方法    func    ；   

  类型参数也存在作用域覆盖的问题，可以在一个泛型类、接口中继续定义泛型方法  

  C.     方法中的泛型参数无须显式传入实际类型参数，编译器会根据传入的实参类型自动推断类型参数。   

  例如：    <T> void func(T t){ ... }    隐式调用    object.func("name")    ，根据    ”name”    的类型    String    推断出类型参数    T    的类型是    String    。当然也可以显式指定，类型参数要写在尖括号中并放在方法名之前，例如：    object.<String> func("String")  

  D.     在使用泛型方法时应避免歧义，例如：    <T> void func(T t1, T t2){ ... }    如果这样调用的话    object.func("name", 15);    会有很大隐患，    T    到底应该是    String    还是    Integer    存在歧义。  

## 类型通配符

  List<?>    传    List<int>    或者    List<String>    都可以。  

  List<? extends Number>    只能传入    Number    类型的子类    Int    或者    Double    。  

  List<? super Integer>    只能传入    Inerger    的父类    Number    或者    Double    等。

  1.    方法参数带有通配符会更加通用；      2.    带有通配符类型的对象，被限制了与泛型相关方法的使用；      3.    上边界通配符：可以使用参数为泛型变量的方法。      4.    下边界通配符：可以使用返回值为泛型变量的方法；  

  5.    当使用通配符时，对泛型类中的参数为泛型的方法起到了副作用，不能再使用 

# 1.11.1 流结构体系与分类

## 1.2.1.按流方向分类

  从流的方向上可分为两类    (    在    java    中是站在程序角度来区分流的方向，将数据读取到程序中就是输入流；反之，将程序中的数据写出去就是输出流    )    ：   

  -     输入流：     从数据源中将数据读取到程序中的流。   

  -     输出流：程序将数据写入到目的地的流。

## 1.2.2.按流的数据类型分类

  字节流：     以    8    位的字节形式来读写的流。他们的标志是名称以    Stream    结尾。    InputStream    与    OutputStream    分别是所有字节输入流与字节输出流的抽象父类。  

  字符流：     以字符形式来读写的流。它们的标志是名称以    Reader    或者    Writer    结尾。并且    Reader    和    Writer    分别是所有字符输入流与字符输出流的抽象父类。  

  1.Java IO    是采用的是装饰模式，即采用处理流来包装节点流的方式，来达到代码通用性。  

  2.    处理流和节点流的区分方法，节点流在新建时需要一个数据源（文件、网络）作为参数，而处理流需要一个节点流作为参数。  

  3.    处理流的作用就是提高代码通用性，编写代码的便捷性，提高性能。  

  4.    节点流都是对应抽象基类的实现类，它们都实现了抽象基类的基础读写方法。其中    read    （）方法如果返回    -1    ，代表已经读到数据源末尾。

# 1.11.3 使用缓冲流提高性能

  一、缓冲输入流  

​          BufferedInputStream extends FileInputStream    ，缓冲流的设计思想是基于装饰器设计模式的，需要在构造缓冲流的时候传入一个节点流。

​          缓冲输入流为什么能够提高效率？

​          简单一句话就是空间换时间。    read    方法虽然是一个字节一个字节的返回数据，但是他实际上是一次就读取了    buf    个字节，然后从    buf    中返回给    read    方法，如果取光了，在    read    一次，如此往复。也就是说，采用了缓冲技术之后，缓冲流调用本地    IO    的次数变为    file.length/buf.length    ，默认    buf    是    8192    个字节，因此    read    方法的性能提高了约    8192    倍。当然这不是不需要花费代价的，花费的代价就是多消耗了    8191    个内存字节。

  举个简单例子，在    A    地有    10000    本书需要搬到    B    地，如果一次搬    1    本，需要    10000    次。如果每次取    1000    本放到一个货车上，运到    B    地，需要    10    次完成。货车相当于是缓存区。同样道理，开设一个数据缓存区每次读取一数据块对于提高读取效率有显著提升。下面用一个具体代码示例来表示二者的性能差别。

# 1.12.1 多线程概述及作用

  进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含    1--n    个线程。（进程是资源分配的最小单位）

  线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器    (PC)    ，线程切换开销小。（线程是    cpu    调度的最小单位  ）

  线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。  

  多进程是指操作系统能同时运行多个任务（程序）  

  多线程是指在同一程序中有多个顺序流在执行。  

  在    java    中要想实现多线程，有两种手段，一种是继续    Thread    类，另外一种是实现    Runable    接口    .(  其实准确来讲，应该有三种，还有一种是实现Callable接口  ，并与    Future    、线程池结合使用  

  总结：  

  实现    Runnable    接口比继承    Thread    类所具有的优势：  

  1    ）：适合多个相同的程序代码的线程去处理同一个资源  

  2    ）：可以避免    java    中的单继承的限制  

  3    ）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立  

  4    ）：线程池只能放入实现    Runable    或    callable    类线程，不能直接放入继承    Thread    的类 

  1    、新建状态（    New    ）：新创建了一个线程对象。  

  2    、就绪状态（    Runnable    ）：线程对象创建后，其他线程调用了该对象的    start()    方法。该状态的线程位于可运行线程池中，变得可运行，等待获取    CPU    的使用权。  

  3    、运行状态（    Running    ）：就绪状态的线程获取了    CPU    ，执行程序代码。  

  4    、阻塞状态（    Blocked    ）：阻塞状态是线程因为某种原因放弃    CPU    使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：  

  （一）、等待阻塞：运行的线程执行    wait()    方法，    JVM    会把该线程放入等待池中。    (wait    会释放持有的锁    )  

  （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则    JVM    会把该线程放入锁池中。  

  （三）、其他阻塞：运行的线程执行    sleep()    或    join()    方法，或者发出了    I/O    请求时，    JVM    会把该线程置为阻塞状态。当    sleep()    状态超时、    join()    等待线程终止或者超时、或者    I/O    处理完毕时，线程重新转入就绪状态。（注意    ,sleep    是不会释放持有的锁）  

 

  Thread    类的    setPriority()    和    getPriority()    方法分别用来设置和获取线程的优先级。  

   每个线程都有默认的优先级。主线程的默认优先级为    Thread.NORM_PRIORITY    。  

  线程的优先级有继承关系，比如    A    线程中创建了    B    线程，那么    B    将和    A    具有相同的优先级。  

  JVM    提供了    10    个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用    Thread    类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。  

  2    、线程睡眠：    Thread.sleep(long millis)    方法，使线程转到阻塞状态。    millis    参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（    Runnable    ）状态。    sleep()    平台移植性好。  

  3    、线程等待：    Object    类中的    wait()    方法，导致当前的线程等待，直到其他线程调用此对象的     notify()     方法或     notifyAll()     唤醒方法。这个两个唤醒方法也是    Object    类中的方法，行为等价于调用     wait(0)     一样。  

  4    、线程让步：    Thread.yield()     方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。  

  5    、线程加入：    join()    方法，等待其他线程终止。在当前线程中调用另一个线程的    join()    方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。  

  6    、线程唤醒：    Object    类中的    notify()    方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个     wait     方法，在对象的监视器上等待。     直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个    notifyAll()    ，唤醒在此对象监视器上等待的所有线程。  

# 1.12.2 多线程实现方案

## 一、继承Thread实现多线程

  问题    1    、为什么要重新    run()    方法？  

  因为    run()    方法里面封装的是要被该线程执行的代码  

  问题    2    、    run()    方法和    start()    方法的区别？  

   如果直接调用    run()    方法就是普通的方法调用，调用    start()    方法是先启动线程，获取到    cpu    执行权后由    JVM    调用其中的    run()    方法  

## 二、实现Runnable接口实现多线程

   ![1566480305345](C:\Users\寒\AppData\Roaming\Typora\typora-user-images\1566480305345.png)

## 三、两种实现方法的区别

​     实现    Runnable    接口带来的好处：  

  1    、避免    JAVA    单继承带来的局限性。  

​     由于    JAVA    是单继承的，如果当前自定义的类已经继承了一个类，就不能再继承    Thread    类来实现多线程了，但是，我们可以通过实现    Runnable    来避免这个局限性，同时    JAVA    还是多实现的，可以同时实现多个接口，因此实现    Runnable    接口更加的方便。  

  2    、适合多个相同的程序代码去处理同一个资源的情况，把线程同程序的代码、数据有效的分离，较好的体现面向对象的设计思想。  

​     当多个线程需要处理同一资源时，我们可以将资源在    Runnable    接口中定义，这样，创建    Thread    对象时传入相同的    Runnable    对象就可以实现多线程资源的共享（注：这里需要考虑多线程的线程安全问题，需要考虑同步的问题  

  可以传入多个    Runnable    对象来实现多线程共享  

# 1.12.3 线程调度和线程控制

## 一、线程调度

  线程调度是指  系统为线程分配处理器使用权的过程  ，主要调度方式有两种，分别是  协同式线程调度  和  抢占式线程调度  。  

### 1.1 协同式线程调度

协同式线程调度，线程的执行时间由线程本身控制。协同式线程调度，线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。

  优点：     实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。  

  缺点：     线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。  

### 1.2 抢占式线程调度

  抢占式调度，  每个线程将由系统来分配执行时间，线程的切换不由线程本身来  决定。  

  线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。  

优点：   线程执行时间系统可控，也不会有一个线程导致整个进程阻塞。  

 # 1.12.5 线程同步

## 为何要使用同步？    

java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 
    将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 
    从而保证了该变量的唯一性和准确性。

## 1.同步方法

既有synchronized关键字修饰方法时，

由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，

内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

代码如：

```java
public synchronized void said(){

}
```

注：synchronized的关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。

## 2.同步代码块

既有synchronized关键字修饰的语句块

被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

代码如

```java
synchronized（object）{

}
```

注：同步是一个高开销的操作，因此应该尽量减少同步的内容。

通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

## 3.使用特殊域变量（volatile)实现线程同步

  a.volatile关键字为域变量的访问提供了一种免锁机制， 
    b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
    c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 
    d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

# 1.13.1网络编程概述及作用

## 8.1.1 网络基础知识

网络编程中有两个主要的问题，一个是如何准确的定位网络上一台或多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。而TCP层则提供面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。

目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。

## 8.1.3两类传输协议：TCP；UDP

尽管TCP/IP协议的名称中只有TCP这个协议名，但是在TCP/IP的传输层同时存在TCP和UDP两个协议。
TCP是Tranfer Control Protocol的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。

UDP每个数据报中都给出了完整的地址信息，因此无需间理发送方和接受方的连接。对于TCP协议，由于是一个面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中多了一个建立时间。

### 区别

既然有了保证可靠传输的TCP协议，为什么还要非可靠传输的UDP协议呢？主要的原因有两个。一是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。二是在许多应用中并不需要保证严格的传输可靠性，比如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。

## 8.2.1一致资源定位器URL

URL是一致资源定位器的简称，它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源，比如最常见的WWW，FTP站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。

## 8.2.2 URL的组成

[http://www.gamelan.com:80/Gamelan/network.html#BOTTOM](http://www.gamelan.com/Gamelan/network.html#BOTTOM) 协议名://机器名＋端口号＋文件名＋内部引用.

# 1.13.2 网络编程三要素

## 1、什么是网络编程

网络编程：使用编程语言实现多台计算机的通信。

## 2、网络编程三大要素

- IP地址：网络中每一台计算机的唯一标识，通过IP地址来找到指定的计算机。

- 端口：用于标识进程的逻辑地址，通过端口号找到指定进程。
- 协议：定义通信规则，符合协议则可以通信，不符合不能通信。

举例：

假如我要和小明说话，首先我要到小明的住址找到小明（相当于通过IP找到指定计算机）；之后我要和小明说话，小明用耳朵听我说（相当于用端口接收）；而我们对话不能使用鸟语，需要作出规定彼此都要使用都能听懂的普通话（这就是协议的作用了）。

## 3、详解IP地址

IP地址：是网络中计算机的唯一标识，通过IP地址可以找到指定计算机。

### IP地址分为五类

A类 1.0.0.1---127.255.255.254（10.X.X.X是私有地址、127.X.X.X是保留地址）

　　　　B类 128.0.0.1---191.255.255.254（172.16.0.0---172.31.255.255是私有地址，169.254.X.X是保留地址）

　　　　C类 192.0.0.1---223.255.255.254，（192.168.X.X也是私有地址，还记得我们大学的网关就是192.168.26.254）

　　　　D类 224.0.0.1---239.255.255.254（保留地址） 

　　　　E类 240.0.0.1---247.255.255.254（保留地址）

**附：**私有地址，是在互联网上不使用，被用在局域网络中的地址。

IP地址的组成：IP地址由网络号（不可变）和主机地址（可变）组成（表示形式：IP地址=网络号+主机地址）。

A类IP地址：第一段号码为网络号码，剩下的三段是本地计算机的号码，所以A类共有 256*256*256=16777216，一千多万个IP地址，貌似中国电信有A类地址。

　　　　B类IP地址：前二段号码为网络号码，剩下的二段是本地计算机的号码，共65536个IP，大型学校可以用B类。

　　　　C类IP地址：前三段号码为网络号码，剩下的一段号码为本地计算机的号码，共256个IP，一般公司可以使用。

# 1.13.3 TCP/IP参考模型

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180816221703700?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtZDEyMzQ1Njc4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180816221735999?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtZDEyMzQ1Njc4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### IP 协议

IP 网络中每台主机都有唯一的 IP 地址。主机实际上有两个不同性子的地址：物理地址和 IP 地址。物理地址是由主机上的网卡来标识，物理地址才是主机的真实地址。 
（1）IP 是面向包的协议，即数据被分成若干小数据包，然后分别传输他们。 
（2）IP 协议，当源主机和目标主机在同一个网络上时，能够直接发送数据包到目标主机。当目标主机在另一个网络时，需要通过 ARP协议，即地址解析协议，获得目标主机的物理地址，然后再把包发给对方。 
（3）IP 协议并不保证一定把数据包送达目标主机，在发送过程中，会因为数据包结束生命周期或者找不到路由而丢弃数据包。

### TCP 协议及端口

IP 协议在发送数据包时，发生数据包丢失或者顺序搞乱时，TCP 协议依然能够保证两台主机上的进程顺利通信，不担心这两个问题的发生。因为 TCP 跟踪包顺序，并且在包顺序搞乱时按正确顺序重组包。如果包丢失，则 TCP 会请求源主机重发包。

TCP 采用端口来区分进程间通信。如下图所示： ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180816221825578?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtZDEyMzQ1Njc4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

端口号的范围为 0~65535，其中 0~1023 的端口号一般固定分配给一些服务。1024~65535的端口号供用户自定义服务使用。 

TCP 和 UDP 用的端口是相互独立的，即允许存在取值相同的 TCP 端口和 UDP 端口。如下图所示： ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180816221904902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtZDEyMzQ1Njc4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



应用层一些通用服务使用的端口如下：![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180816221931714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtZDEyMzQ1Njc4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 1.14.1 反射的原理分析

### 一：Java的反射就是把Jva类中的各种成分映射成相应的Java类。

例如：一个Java类中用一个Class类的对象来表示此Java类中的组成部分：成员变量，方法，构造方法，包等信息也用一个个的Java类来表示。

比如汽车是一个类，汽车中的发动机中的发动机，变速箱等一个一个个的类。

### 二：一句话概括：反射就是把Java类中的各个成分映射成相应的Java类。

### 三：反射的基石：Class类（Java程序中的各个Java类属于同一事物，描述这类事务的类就是Class类）

### 四：表示Java类的Class类显然要提供一系列的方法来获取其中的变量，方法，构造方法，修饰符，包，等信息。（对应映射到类Field，Method，Constructor，Package）等。

### 五：得到映射对象，必须先得到字节码!三种方式获取字节码。

 1.   对象.getClass()                     Person p=new Person();   Class clazz=p.getClass();   //类的字节码已经加载到内存，只需要对象调用

 2. 类加载器                               Class clazz=Class.forName("java.lang.String");           //类的完整名称

 3. 类名.Class                             Class clazz=Person.class; 
 ### 六：8个基本类型对应8个Class对象(boolean, byte, char, short, int, long, float, double)+void

Class.isPrimitive()判断是否为八大基本类型。

## 单项链表

  包含信息域和指针域，只可向一个方向遍历，查找一个节点只能从第一个访问到最后一个。  

# 1.14.2 JVM与类

## 1、什么是类的加载

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java,lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的`Class`对象，`Class`对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

![img](http://favorites.ren/assets/images/2017/jvm/jvm-1.png)

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

**加载.class文件的方式**

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip，jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件
## 2、类的生命周期

![img](http://favorites.ren/assets/images/2017/jvm/class.png)

其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

**加载**

查找查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

- 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口。

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个`java.lang.Class`类的对象，这样便可以通过该对象访问方法区中的这些数据。连接

**验证：确保被加载的类的正确性**

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

- **文件格式验证**：验证字节流是否符合Class文件格式的规范；例如：是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- **元数据验证**：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了`java.lang.Object`之外。
- **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- **符号引用验证**：确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

**准备：为类的静态变量分配内存，并将其初始化为默认值**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

- 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为：`public static int value = 3`；

那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`public static`指令是在程序编译后，存放于类构造器`<clinit>（）`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

> 这里还需要注意如下几点：
>
> - 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
> - 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
> - 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
> - 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

- 3、如果类字段的字段属性表中存在`ConstantValue`属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

假设上面的类变量value被定义为： `public static final int value = 3`；

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据`ConstantValue`的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

**解析：把类中的符号引用转换为直接引用**

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。*符号引用*就是一组符号来描述目标，可以是任何字面量。

*直接引用*就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

**初始化**

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

- ①声明类变量是指定初始值
- ②使用静态代码块为类变量指定初始值

JVM初始化步骤

- 1、假如这个类还没有被加载和连接，则程序先加载并连接该类
- 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 3、假如类中有初始化语句，则系统依次执行这些初始化语句

类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

- 创建类的实例，也就是new的方式
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（如`Class.forName(“com.shengsiyuan.Test”)`）
- 初始化某个类的子类，则其父类也会被初始化
- Java虚拟机启动时被标明为启动类的类（`Java Test`），直接使用`java.exe`命令来运行某个主类

**结束生命周期**

在如下几种情况下，Java虚拟机将结束生命周期

- 执行了`System.exit()`方法

- 程序正常执行结束

- 程序在执行过程中遇到了异常或错误而异常终止

- 由于操作系统出现错误而导致Java虚拟机进程终止

## 3、类加载器

  寻找类加载器，先来一个小例子

  ```
  package com.neo.classloader;
  public class ClassLoaderTest {
       public static void main(String[] args) {
          ClassLoader loader = Thread.currentThread().getContextClassLoader();
          System.out.println(loader);
          System.out.println(loader.getParent());
          System.out.println(loader.getParent().getParent());
      }
  }
  ```

  运行后，输出结果：

  ```
  sun.misc.Launcher$AppClassLoader@64fef26a
  sun.misc.Launcher$ExtClassLoader@1ddd40f3
  null
  ```

  从上面的结果可以看出，并没有获取到`ExtClassLoader`的父Loader，原因是`Bootstrap Loader`（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。

  这几种类加载器的层次关系如下图所示：

  ![img](http://favorites.ren/assets/images/2017/jvm/calssloader.png)

  > 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。

  站在Java虚拟机的角度来讲，只存在两种不同的类加载器：*启动类加载器*：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有*其它的类加载器*：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类`java.lang.ClassLoader`，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

  站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：

  **启动类加载器**：`Bootstrap ClassLoader`，负责加载存放在`JDK\jre\lib`(JDK代表JDK的安装目录，下同)下，或被`-Xbootclasspath`参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。*

**扩展类加载器**：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
 **应用程序类加载器**：`Application ClassLoader`，该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

  应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：

  - 1、在执行非置信代码之前，自动验证数字签名。
  - 2、动态地创建符合用户特定需要的定制化构建类。
  - 3、从特定的场所取得java class，例如数据库中和网络中。

  **JVM类加载机制**

  - **全盘负责**，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
  - **父类委托**，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
  - **缓存机制**，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

  ## 4、类的加载

  类加载有三种方式：

  - 1、命令行启动应用时候由JVM初始化加载
  - 2、通过Class.forName()方法动态加载
  - 3、通过ClassLoader.loadClass()方法动态加载

  例子：

  ```
  package com.neo.classloader;
  public class loaderTest { 
          public static void main(String[] args) throws ClassNotFoundException { 
                  ClassLoader loader = HelloWorld.class.getClassLoader(); 
                  System.out.println(loader); 
                  //使用ClassLoader.loadClass()来加载类，不会执行初始化块 
                  loader.loadClass("Test2"); 
                  //使用Class.forName()来加载类，默认会执行初始化块 
                  //Class.forName("Test2"); 
                  //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 
                  //Class.forName("Test2", false, loader); 
          } 
  }
  ```

  demo类

  ```
  public class Test2 { 
          static { 
                  System.out.println("静态初始化块执行了！"); 
          } 
  }
  ```

  分别切换加载方式，会有不同的输出结果。

  **Class.forName()和ClassLoader.loadClass()区别**

  - `Class.forName()`：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
  - `ClassLoader.loadClass()`：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
  - `Class.forName(name, initialize, loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

  ## 5、双亲委派模型

  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

  双亲委派机制:

  - 1、当`AppClassLoader`加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器`ExtClassLoader`去完成。
  - 2、当`ExtClassLoader`加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。
  - 3、如果`BootStrapClassLoader`加载失败（例如在`$JAVA_HOME/jre/lib`里未查找到该class），会使用`ExtClassLoader`来尝试加载；
  - 4、若ExtClassLoader也加载失败，则会使用`AppClassLoader`来加载，如果`AppClassLoader`也加载失败，则会报出异常`ClassNotFoundException`。

  ClassLoader源码分析：

  ```
  public Class<?> loadClass(String name)throws ClassNotFoundException {
          return loadClass(name, false);
  }
  
  protected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {
          // 首先判断该类型是否已经被加载
          Class c = findLoadedClass(name);
          if (c == null) {
              //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
              try {
                  if (parent != null) {
                       //如果存在父类加载器，就委派给父类加载器加载
                      c = parent.loadClass(name, false);
                  } else {
                  //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
                      c = findBootstrapClass0(name);
                  }
              } catch (ClassNotFoundException e) {
               // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
                  c = findClass(name);
              }
          }
          if (resolve) {
              resolveClass(c);
          }
          return c;
      }
  ```

  双亲委派模型意义：

  - 系统类防止内存中出现多份同样的字节码
  - 保证Java程序安全稳定运行

  ## 6、自定义类加载器

  通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自`ClassLoader`类，从上面对`loadClass`方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：

  ```
  package com.neo.classloader;
  import java.io.*;
  
  public class MyClassLoader extends ClassLoader {
      private String root;
  
      protected Class<?> findClass(String name) throws ClassNotFoundException {
          byte[] classData = loadClassData(name);
          if (classData == null) {
              throw new ClassNotFoundException();
          } else {
              return defineClass(name, classData, 0, classData.length);
          }
      }
  
      private byte[] loadClassData(String className) {
          String fileName = root + File.separatorChar
                  + className.replace('.', File.separatorChar) + ".class";
          try {
              InputStream ins = new FileInputStream(fileName);
              ByteArrayOutputStream baos = new ByteArrayOutputStream();
              int bufferSize = 1024;
              byte[] buffer = new byte[bufferSize];
              int length = 0;
              while ((length = ins.read(buffer)) != -1) {
                  baos.write(buffer, 0, length);
              }
              return baos.toByteArray();
          } catch (IOException e) {
              e.printStackTrace();
          }
          return null;
      }
  
      public String getRoot() {
          return root;
      }
  
      public void setRoot(String root) {
          this.root = root;
      }
  
      public static void main(String[] args)  {
  
          MyClassLoader classLoader = new MyClassLoader();
          classLoader.setRoot("E:\\temp");
  
          Class<?> testClass = null;
          try {
              testClass = classLoader.loadClass("com.neo.classloader.Test2");
              Object object = testClass.newInstance();
              System.out.println(object.getClass().getClassLoader());
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          } catch (InstantiationException e) {
              e.printStackTrace();
          } catch (IllegalAccessException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：

  - 1、这里传递的文件名需要是类的全限定性名称，即`com.paddx.test.classloading.Test`格式的，因为 defineClass 方法是按这种格式进行处理的。

  - 2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。

  - 3、这类Test 类本身可以被 `AppClassLoader`类加载，因此我们不能把`com/paddx/test/classloading/Test.class`放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由`AppClassLoader`加载，而不会通过我们自定义类加载器来加载。

# 1.14.5 反射入口类之Class

**反射的入口：java.lang.Class**

日常开发中的对象，分为两种，基本类型和引用类型：

基本类型，（固定的 8 种） 
整数：byte, short, int, long
小数：float, double
字符：char
布尔值：boolean
引用类型 
所有的引用类型都继承自 java.lang.Object
类，枚举，数组，接口都是引用类型
java.io.Serializable 接口，基本类型的包装类（比如 java.lang.Double）也是引用类型
对每一种对象，JVM 都会实例化一个 java.lang.Class 的实例，java.lang.Class 为我们提供了在运行时访问对象的属性和类型信息的能力。Class 还提供了创建新的类和对象的能力。最重要的是，Class 是调用其他反射 API 的入口，我们必须先获得一个 Class 实例才可以进行接下来的操作。

得到一个 Class 对象
除了 java.lang.reflect.ReflectPermission 以外，java.lang.reflect 中的其他类都没有 public 的构造函数，也就是说要得到这些类，我们必须通过 Class 。

下面是几种得到 Class 对象的不同方法：

1.Object.getClass 方法

如果我们已经拿到了一个对象，可以很方便地使用它的 getClass 方法获得一个 Class 对象(当然这仅限于引用类型的对象)：

Class c = "shixinzhang.top".getClass();
1
返回的对象 c 是 String 类型。

enum Sex{
    FEMALE,
    MALE
}

Class c = FEMALE.getClass();
1
2
3
4
5
6
上述例子中 FEMALE 是 枚举 Sex 的实例，因此 FEMALE.getClass() 返回的就是 枚举类型 Sex 的 Class。

byte[] bytes = new byte[1024];
Class<? extends byte[]>c = bytes.getClass();
1
2
由于数组也是 Object 的一种，因此我们可以调用 getClass() 方法获得 byte 数组类型的 Class。

2. .class 语法

如果我们当前没有某个类的对象，无法使用 getClass() 方法，那还可以使用另外一种方法获取 Class：在要获得的类名后加上 .class ，比如这样：

Integer.class.newInstance();
int.class.newInstance()
1
2
可以看到，这种方式不仅能用于引用类型，基本类型也可以。

当然数组也可以喽：

Class b = int[][].class;
1
3.Class.forName()

如果我们有一个类的完整路径，就可以使用 Class.forName(“类完整的路径”) 来得到相应的 Class，这个方法只能用于引用类型，比如：

Class<?> c = Class.forName("java.lang.String");
Class<?> aClass = Class.forName("top.shixinzhang.androiddemo2.beans.BookBean");
1
2
4.静态属性 TYPE

上面介绍，使用 .class 后缀可以很方便地获得基本类型的 Class。

对于基本类型和 void 的包装类，还有另外一种方式获得 Class，那就是静态属性 TYPE 。

每个包装类都有 TYPE 属性，以 Double 为例：

```java
public static final Class<Double> TYPE
        = (Class<Double>) double[].class.getComponentType();
```

public static final Class<Double> TYPE
可以看到这个属性就是使用 .class 的方式获得 Class 并保存。

因此我们可以直接调用包装类的 TYPE：

```java
Class<Integer> integerWrapper = Integer.TYPE;
Class<Double> doubleWrapper = Double.TYPE;
Class<Void> voidWrapper = Void.TYPE;5.返回 Class 的方法
```

如果我们已经有了一个 Class，可以使用下面的一些方法来获得它相关的类：

Class.getSuperclass() 
返回调用类的父类
Class.getClasses() 
返回调用类的所有公共类、接口、枚举组成的 Class 数组，包括继承的
Class.getDeclaredClasses() 
返回调用类显式声明的所有类、接口、枚举组成的 Class 数组
Class.getDeclaringClass()
java.lang.reflect.Field.getDeclaringClass()
java.lang.reflect.Method.getDeclaringClass()
java.lang.reflect.Constructor.getDeclaringClass() 
返回类/属性/方法/构造器所在的类
## 双向链表,也叫双链表

  双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。第一个节点的    "    前连接    "    指向    NULL    ，最后一个节点的    "    后连接    "    指向    NULL    。  

  这样可以从任何一个节点访问前一个节点，也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。  

  由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。  

  有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个循环链表。这个虚拟节点之后的节点就是真正的第一个节点  